
// Eventable Mixin.
//
// Simple mixin to add event emitter methods to an object (Publish/Subscribe).
//
// Add on, off and notify methods to an object:
// eventable(obj);
//
// publish an event:
// obj.notify(context, 'action', param1, param2);
//
// Optionally pass a context that will be applied to every event:
// eventable(obj, context);
//
// With this publishing can omit the context argument:
// obj.notify('action', param1, param2);
//
// Subscribe to a 'channel'
// obj.on('action', funtion(param1, param2){ ... });
//
// Unsubscribe an individual listener:
// obj.off('action', method);
//
// Unsubscribe all listeners of a channel:
// obj.off('action');
//
// Unsubscribe all listeners of all channels:
// obj.off();
var getEventableModule = function(notifyContext) {
  var listeners = {};

  var addListener = function(event, listener) {
    if (listeners[event] === undefined) {
      listeners[event] = [];
    }
    listeners[event].push(listener);
  };

  var removeListener = function(event, listener) {
    var eventListeners = listeners[event];
    if (eventListeners === undefined) return;

    for (var i = 0, len = eventListeners.length; i < len; i++) {
      if (eventListeners[i] === listener) {
        eventListeners.splice(i, 1);
        break;
      }
    }
  };

  // Public Methods
  return {
    on: function(event, listener) {
      if (arguments.length === 2) {
        addListener(event, listener);
      } else if (arguments.length === 1) {
        var eventObj = event;
        for (var eventType in eventObj) {
          addListener(eventType, eventObj[eventType]);
        }
      }
      return this;
    },

    off: function(event, listener) {
      if (arguments.length === 2) {
        removeListener(event, listener);
      } else if (arguments.length === 1) {
        listeners[event] = [];
      } else {
        listeners = {};
      }
    },

    notify: function(context, event) {
      var args = Array.prototype.slice.call(arguments);
      if (notifyContext) {
        event = context;
        context = notifyContext;
        args = args.splice(1);
      } else {
        args = args.splice(2);
      }
      var eventListeners = listeners[event];
      if (eventListeners === undefined) return;

      // Traverse backwards and execute the newest listeners first.
      // Stop if a listener returns false.
      for (var i = eventListeners.length - 1; i >= 0; i--) {
        // debugger
        if (eventListeners[i].apply(context, args) === false)
          break;
      }
    }
  };

};

module.exports = function(obj, notifyContext) {
  var module = getEventableModule(notifyContext);
  for (var prop in module) {
    obj[prop] = module[prop];
  }
};
